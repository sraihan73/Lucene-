#pragma once
#include "stringhelper.h"
#include <memory>
#include <mutex>
#include <string>
#include <deque>

// C++ NOTE: Forward class declarations:
namespace org::apache::lucene::store
{
class Directory;
}

namespace org::apache::lucene::search
{
class IndexSearcher;
}
namespace org::apache::lucene::search::spell
{
class StringDistance;
}
namespace org::apache::lucene::search::spell
{
class SuggestWord;
}
namespace org::apache::lucene::index
{
class IndexReader;
}
namespace org::apache::lucene::search
{
class BooleanQuery;
}
namespace org::apache::lucene::search
{
class Builder;
}
namespace org::apache::lucene::index
{
class IndexWriterConfig;
}
namespace org::apache::lucene::search::spell
{
class Dictionary;
}
namespace org::apache::lucene::document
{
class Document;
}

/*
 * Licensed to the Syed Mamun Raihan (sraihan.com) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * sraihan.com licenses this file to You under GPLv3 License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     https://www.gnu.org/licenses/gpl-3.0.en.html
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
namespace org::apache::lucene::search::spell
{

using Document = org::apache::lucene::document::Document;
using IndexReader = org::apache::lucene::index::IndexReader;
using IndexWriterConfig = org::apache::lucene::index::IndexWriterConfig;
using BooleanQuery = org::apache::lucene::search::BooleanQuery;
using IndexSearcher = org::apache::lucene::search::IndexSearcher;
using Directory = org::apache::lucene::store::Directory;

/**
 * <p>
 *   Spell Checker class  (Main class).<br>
 *  (initially inspired by the David Spencer code).
 * </p>
 *
 * <p>Example Usage:
 *
 * <pre class="prettyprint">
 *  SpellChecker spellchecker = new SpellChecker(spellIndexDirectory);
 *  // To index a field of a user index:
 *  spellchecker.indexDictionary(new LuceneDictionary(my_lucene_reader,
 * a_field));
 *  // To index a file containing words:
 *  spellchecker.indexDictionary(new PlainTextDictionary(new
 * File("myfile.txt"))); std::wstring[] suggestions =
 * spellchecker.suggestSimilar("misspelt", 5);
 * </pre>
 *
 *
 */
class SpellChecker : public std::enable_shared_from_this<SpellChecker>
{
  GET_CLASS_NAME(SpellChecker)

  /**
   * The default minimum score to use, if not specified by calling {@link
   * #setAccuracy(float)} .
   */
public:
  static constexpr float DEFAULT_ACCURACY = 0.5f;

  /**
   * Field name for each word in the ngram index.
   */
  static const std::wstring F_WORD;

  /**
   * the spell index
   */
  // don't modify the directory directly - see #swapSearcher()
  // TODO: why is this package private?
  std::shared_ptr<Directory> spellIndex;
  /**
   * Boost value for start and end grams
   */
private:
  float bStart = 2.0f;

  float bEnd = 1.0f;
  // don't use this searcher directly - see #swapSearcher()

  std::shared_ptr<IndexSearcher> searcher;
  /*
   * this locks all modifications to the current searcher.
   */

  std::mutex searcherLock;
  /*
   * this lock synchronizes all possible modifications to the
   * current index directory. It should not be possible to try modifying
   * the same index concurrently. Note: Do not acquire the searcher lock
   * before acquiring this lock!
   */
  std::mutex modifyCurrentIndexLock;

  // C++ TODO: 'volatile' has a different meaning in C++:
  // ORIGINAL LINE: private volatile bool closed = false;
  bool closed = false;
  // minimum score for hits generated by the spell checker query

  float accuracy = DEFAULT_ACCURACY;

  std::shared_ptr<StringDistance> sd;
  std::shared_ptr<Comparator<std::shared_ptr<SuggestWord>>> comparator;

  /**
   * Use the given directory as a spell checker index. The directory
   * is created if it doesn't exist yet.
   * @param spellIndex the spell index directory
   * @param sd the {@link StringDistance} measurement to use
   * @throws IOException if Spellchecker can not open the directory
   */
public:
  SpellChecker(std::shared_ptr<Directory> spellIndex,
               std::shared_ptr<StringDistance> sd) ;
  /**
   * Use the given directory as a spell checker index with a
   * {@link LevenshteinDistance} as the default {@link StringDistance}. The
   * directory is created if it doesn't exist yet.
   *
   * @param spellIndex
   *          the spell index directory
   * @throws IOException
   *           if spellchecker can not open the directory
   */
  SpellChecker(std::shared_ptr<Directory> spellIndex) ;

  /**
   * Use the given directory as a spell checker index with the given {@link
   * org.apache.lucene.search.spell.StringDistance} measure and the given {@link
   * java.util.Comparator} for sorting the results.
   * @param spellIndex The spelling index
   * @param sd The distance
   * @param comparator The comparator
   * @throws IOException if there is a problem opening the index
   */
  SpellChecker(std::shared_ptr<Directory> spellIndex,
               std::shared_ptr<StringDistance> sd,
               std::shared_ptr<Comparator<std::shared_ptr<SuggestWord>>>
                   comparator) ;

  /**
   * Use a different index as the spell checker index or re-open
   * the existing index if <code>spellIndex</code> is the same value
   * as given in the constructor.
   * @param spellIndexDir the spell directory to use
   * @throws AlreadyClosedException if the Spellchecker is already closed
   * @throws  IOException if spellchecker can not open the directory
   */
  // TODO: we should make this final as it is called in the constructor
  virtual void
  setSpellIndex(std::shared_ptr<Directory> spellIndexDir) ;

  /**
   * Sets the {@link java.util.Comparator} for the {@link SuggestWordQueue}.
   * @param comparator the comparator
   */
  virtual void setComparator(
      std::shared_ptr<Comparator<std::shared_ptr<SuggestWord>>> comparator);

  /**
   * Gets the comparator in use for ranking suggestions.
   * @see #setComparator(Comparator)
   */
  virtual std::shared_ptr<Comparator<std::shared_ptr<SuggestWord>>>
  getComparator();

  /**
   * Sets the {@link StringDistance} implementation for this
   * {@link SpellChecker} instance.
   *
   * @param sd the {@link StringDistance} implementation for this
   * {@link SpellChecker} instance
   */
  virtual void setStringDistance(std::shared_ptr<StringDistance> sd);
  /**
   * Returns the {@link StringDistance} instance used by this
   * {@link SpellChecker} instance.
   *
   * @return the {@link StringDistance} instance used by this
   *         {@link SpellChecker} instance.
   */
  virtual std::shared_ptr<StringDistance> getStringDistance();

  /**
   * Sets the accuracy 0 &lt; minScore &lt; 1; default {@link #DEFAULT_ACCURACY}
   * @param acc The new accuracy
   */
  virtual void setAccuracy(float acc);

  /**
   * The accuracy (minimum score) to be used, unless overridden in {@link
   * #suggestSimilar(std::wstring, int, IndexReader, std::wstring, SuggestMode, float)}, to
   * decide whether a suggestion is included or not.
   * @return The current accuracy setting
   */
  virtual float getAccuracy();

  /**
   * Suggest similar words.
   *
   * <p>As the Lucene similarity that is used to fetch the most relevant
   * n-grammed terms is not the same as the edit distance strategy used to
   * calculate the best matching spell-checked word from the hits that Lucene
   * found, one usually has to retrieve a couple of numSug's in order to get the
   * true best match.
   *
   * <p>I.e. if numSug == 1, don't count on that suggestion being the best one.
   * Thus, you should set this value to <b>at least</b> 5 for a good suggestion.
   *
   * @param word the word you want a spell check done on
   * @param numSug the number of suggested words
   * @throws IOException if the underlying index throws an {@link IOException}
   * @throws AlreadyClosedException if the Spellchecker is already closed
   * @return std::wstring[]
   *
   * @see #suggestSimilar(std::wstring, int, IndexReader, std::wstring, SuggestMode, float)
   */
  virtual std::deque<std::wstring>
  suggestSimilar(const std::wstring &word, int numSug) ;

  /**
   * Suggest similar words.
   *
   * <p>As the Lucene similarity that is used to fetch the most relevant
   * n-grammed terms is not the same as the edit distance strategy used to
   * calculate the best matching spell-checked word from the hits that Lucene
   * found, one usually has to retrieve a couple of numSug's in order to get the
   * true best match.
   *
   * <p>I.e. if numSug == 1, don't count on that suggestion being the best one.
   * Thus, you should set this value to <b>at least</b> 5 for a good suggestion.
   *
   * @param word the word you want a spell check done on
   * @param numSug the number of suggested words
   * @param accuracy The minimum score a suggestion must have in order to
   * qualify for inclusion in the results
   * @throws IOException if the underlying index throws an {@link IOException}
   * @throws AlreadyClosedException if the Spellchecker is already closed
   * @return std::wstring[]
   *
   * @see #suggestSimilar(std::wstring, int, IndexReader, std::wstring, SuggestMode, float)
   */
  virtual std::deque<std::wstring>
  suggestSimilar(const std::wstring &word, int numSug,
                 float accuracy) ;

  /**
   * Calls {@link #suggestSimilar(std::wstring, int, IndexReader, std::wstring, SuggestMode,
   * float) suggestSimilar(word, numSug, ir, suggestMode, field, this.accuracy)}
   *
   */
  virtual std::deque<std::wstring>
  suggestSimilar(const std::wstring &word, int numSug,
                 std::shared_ptr<IndexReader> ir, const std::wstring &field,
                 SuggestMode suggestMode) ;

  /**
   * Suggest similar words (optionally restricted to a field of an index).
   *
   * <p>As the Lucene similarity that is used to fetch the most relevant
   * n-grammed terms is not the same as the edit distance strategy used to
   * calculate the best matching spell-checked word from the hits that Lucene
   * found, one usually has to retrieve a couple of numSug's in order to get the
   * true best match.
   *
   * <p>I.e. if numSug == 1, don't count on that suggestion being the best one.
   * Thus, you should set this value to <b>at least</b> 5 for a good suggestion.
   *
   * @param word the word you want a spell check done on
   * @param numSug the number of suggested words
   * @param ir the indexReader of the user index (can be null see field param)
   * @param field the field of the user index: if field is not null, the
   * suggested words are restricted to the words present in this field.
   * @param suggestMode
   * (NOTE: if indexReader==null and/or field==null, then this is overridden
   * with SuggestMode.SUGGEST_ALWAYS)
   * @param accuracy The minimum score a suggestion must have in order to
   * qualify for inclusion in the results
   * @throws IOException if the underlying index throws an {@link IOException}
   * @throws AlreadyClosedException if the Spellchecker is already closed
   * @return std::wstring[] the sorted deque of the suggest words with these 2
   * criteria: first criteria: the edit distance, second criteria (only if
   * restricted mode): the popularity of the suggest words in the field of the
   * user index
   *
   */
  virtual std::deque<std::wstring>
  suggestSimilar(const std::wstring &word, int numSug,
                 std::shared_ptr<IndexReader> ir, const std::wstring &field,
                 SuggestMode suggestMode, float accuracy) ;
  /**
   * Add a clause to a bool query.
   */
private:
  static void add(std::shared_ptr<BooleanQuery::Builder> q,
                  const std::wstring &name, const std::wstring &value,
                  float boost);

  /**
   * Add a clause to a bool query.
   */
  static void add(std::shared_ptr<BooleanQuery::Builder> q,
                  const std::wstring &name, const std::wstring &value);

  /**
   * Form all ngrams for a given word.
   * @param text the word to parse
   * @param ng the ngram length e.g. 3
   * @return an array of all ngrams in the word and note that duplicates are not
   * removed
   */
  static std::deque<std::wstring> formGrams(const std::wstring &text, int ng);

  /**
   * Removes all terms from the spell check index.
   * @throws IOException If there is a low-level I/O error.
   * @throws AlreadyClosedException if the Spellchecker is already closed
   */
public:
  virtual void clearIndex() ;

  /**
   * Check whether the word exists in the index.
   * @param word word to check
   * @throws IOException If there is a low-level I/O error.
   * @throws AlreadyClosedException if the Spellchecker is already closed
   * @return true if the word exists in the index
   */
  virtual bool exist(const std::wstring &word) ;

  /**
   * Indexes the data from the given {@link Dictionary}.
   * @param dict Dictionary to index
   * @param config {@link IndexWriterConfig} to use
   * @param fullMerge whether or not the spellcheck index should be fully merged
   * @throws AlreadyClosedException if the Spellchecker is already closed
   * @throws IOException If there is a low-level I/O error.
   */
  void indexDictionary(std::shared_ptr<Dictionary> dict,
                       std::shared_ptr<IndexWriterConfig> config,
                       bool fullMerge) ;

private:
  static int getMin(int l);

  static int getMax(int l);

  static std::shared_ptr<Document> createDocument(const std::wstring &text,
                                                  int ng1, int ng2);

  static void addGram(const std::wstring &text, std::shared_ptr<Document> doc,
                      int ng1, int ng2);

  std::shared_ptr<IndexSearcher> obtainSearcher();

  void
  releaseSearcher(std::shared_ptr<IndexSearcher> aSearcher) ;

  void ensureOpen();

  /**
   * Close the IndexSearcher used by this SpellChecker
   * @throws IOException if the close operation causes an {@link IOException}
   * @throws AlreadyClosedException if the {@link SpellChecker} is already
   * closed
   */
public:
  virtual ~SpellChecker();

private:
  void swapSearcher(std::shared_ptr<Directory> dir) ;

  /**
   * Creates a new read-only IndexSearcher
   * @param dir the directory used to open the searcher
   * @return a new read-only IndexSearcher
   * @throws IOException f there is a low-level IO error
   */
  // for testing purposes
public:
  virtual std::shared_ptr<IndexSearcher>
  createSearcher(std::shared_ptr<Directory> dir) ;

  /**
   * Returns <code>true</code> if and only if the {@link SpellChecker} is
   * closed, otherwise <code>false</code>.
   *
   * @return <code>true</code> if and only if the {@link SpellChecker} is
   *         closed, otherwise <code>false</code>.
   */
  virtual bool isClosed();
};

} // namespace org::apache::lucene::search::spell
