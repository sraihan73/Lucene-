#pragma once
#include "../../../../../../../../../core/src/java/org/apache/lucene/analysis/CharArrayMap.h"
#include "../util/OpenStringBuilder.h"
#include "BaseCharFilter.h"
#include "exceptionhelper.h"
#include "stringhelper.h"
#include <memory>
#include <optional>
#include <stdexcept>
#include <string>
#include <unordered_map>
#include <deque>

// C++ NOTE: Forward class declarations:
#include  "core/src/java/org/apache/lucene/analysis/CharArraySet.h"

#include  "core/src/java/org/apache/lucene/analysis/charfilter/TextSegment.h"

/* The following code was generated by JFlex 1.6.0 */

/*
 * Licensed to the Syed Mamun Raihan (sraihan.com) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * sraihan.com licenses this file to You under GPLv3 License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     https://www.gnu.org/licenses/gpl-3.0.en.html
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

namespace org::apache::lucene::analysis::charfilter
{

using CharArrayMap = org::apache::lucene::analysis::CharArrayMap;
using CharArraySet = org::apache::lucene::analysis::CharArraySet;
using OpenStringBuilder =
    org::apache::lucene::analysis::util::OpenStringBuilder;

/**
 * A CharFilter that wraps another Reader and attempts to strip out HTML
 * constructs.
 */
// C++ TODO: Most Java annotations will not have direct C++ equivalents:
// ORIGINAL LINE: @SuppressWarnings("fallthrough") public final class
// HTMLStripCharFilter extends BaseCharFilter
class HTMLStripCharFilter final : public BaseCharFilter
{

  /** This character denotes the end of file */
private:
  static constexpr int YYEOF = -1;

  /** initial size of the lookahead buffer */
  static constexpr int ZZ_BUFFERSIZE = 16384;

  /** lexical states */
  static constexpr int YYINITIAL = 0;
  static constexpr int AMPERSAND = 2;
  static constexpr int NUMERIC_CHARACTER = 4;
  static constexpr int CHARACTER_REFERENCE_TAIL = 6;
  static constexpr int LEFT_ANGLE_BRACKET = 8;
  static constexpr int BANG = 10;
  static constexpr int COMMENT = 12;
  static constexpr int SCRIPT = 14;
  static constexpr int SCRIPT_COMMENT = 16;
  static constexpr int LEFT_ANGLE_BRACKET_SLASH = 18;
  static constexpr int LEFT_ANGLE_BRACKET_SPACE = 20;
  static constexpr int CDATA = 22;
  static constexpr int SERVER_SIDE_INCLUDE = 24;
  static constexpr int SINGLE_QUOTED_STRING = 26;
  static constexpr int DOUBLE_QUOTED_STRING = 28;
  static constexpr int END_TAG_TAIL_INCLUDE = 30;
  static constexpr int END_TAG_TAIL_EXCLUDE = 32;
  static constexpr int END_TAG_TAIL_SUBSTITUTE = 34;
  static constexpr int START_TAG_TAIL_INCLUDE = 36;
  static constexpr int START_TAG_TAIL_EXCLUDE = 38;
  static constexpr int START_TAG_TAIL_SUBSTITUTE = 40;
  static constexpr int STYLE = 42;
  static constexpr int STYLE_COMMENT = 44;

  /**
   * ZZ_LEXSTATE[l] is the state in the DFA for the lexical state l
   * ZZ_LEXSTATE[l+1] is the state in the DFA for the lexical state l
   *                  at the beginning of a line
   * l is of the form l = 2*k, k a non negative integer
   */
  static std::deque<int> const ZZ_LEXSTATE;

  /**
   * Translates characters to character classes
   */
  static const std::wstring ZZ_CMAP_PACKED;

  /**
   * Translates characters to character classes
   */
  static std::deque<wchar_t> const ZZ_CMAP;

  /**
   * Translates DFA states to action switch labels.
   */
  static std::deque<int> const ZZ_ACTION;

  static const std::wstring ZZ_ACTION_PACKED_0;

  static std::deque<int> zzUnpackAction();

  static int zzUnpackAction(const std::wstring &packed, int offset,
                            std::deque<int> &result);

  /**
   * Translates a state to a row index in the transition table
   */
  static std::deque<int> const ZZ_ROWMAP;

  static const std::wstring ZZ_ROWMAP_PACKED_0;

  static std::deque<int> zzUnpackRowMap();

  static int zzUnpackRowMap(const std::wstring &packed, int offset,
                            std::deque<int> &result);

  /**
   * The transition table of the DFA
   */
  static std::deque<int> const ZZ_TRANS;

  static const std::wstring ZZ_TRANS_PACKED_0;

  static const std::wstring ZZ_TRANS_PACKED_1;

  static const std::wstring ZZ_TRANS_PACKED_2;

  static const std::wstring ZZ_TRANS_PACKED_3;

  static const std::wstring ZZ_TRANS_PACKED_4;

  static const std::wstring ZZ_TRANS_PACKED_5;

  static const std::wstring ZZ_TRANS_PACKED_6;

  static const std::wstring ZZ_TRANS_PACKED_7;

  static const std::wstring ZZ_TRANS_PACKED_8;

  static const std::wstring ZZ_TRANS_PACKED_9;

  static const std::wstring ZZ_TRANS_PACKED_10;

  static const std::wstring ZZ_TRANS_PACKED_11;

  static const std::wstring ZZ_TRANS_PACKED_12;

  static std::deque<int> zzUnpackTrans();

  static int zzUnpackTrans(const std::wstring &packed, int offset,
                           std::deque<int> &result);

  /* error codes */
  static constexpr int ZZ_UNKNOWN_ERROR = 0;
  static constexpr int ZZ_NO_MATCH = 1;
  static constexpr int ZZ_PUSHBACK_2BIG = 2;

  /* error messages for the codes above */
  static std::deque<std::wstring> const ZZ_ERROR_MSG;

  /**
   * ZZ_ATTRIBUTE[aState] contains the attributes of state <code>aState</code>
   */
  static std::deque<int> const ZZ_ATTRIBUTE;

  static const std::wstring ZZ_ATTRIBUTE_PACKED_0;

  static std::deque<int> zzUnpackAttribute();

  static int zzUnpackAttribute(const std::wstring &packed, int offset,
                               std::deque<int> &result);

  /** the input device */
  std::shared_ptr<Reader> zzReader;

  /** the current state of the DFA */
  int zzState = 0;

  /** the current lexical state */
  int zzLexicalState = YYINITIAL;

  /** this buffer contains the current text to be matched and is
      the source of the yytext() string */
  std::deque<wchar_t> zzBuffer = std::deque<wchar_t>(ZZ_BUFFERSIZE);

  /** the textposition at the last accepting state */
  int zzMarkedPos = 0;

  /** the current text position in the buffer */
  int zzCurrentPos = 0;

  /** startRead marks the beginning of the yytext() string in the buffer */
  int zzStartRead = 0;

  /** endRead marks the last character in the buffer, that has been read
      from input */
  int zzEndRead = 0;

  /** number of newlines encountered up to the start of the matched text */
  int yyline = 0;

  /** the number of characters up to the start of the matched text */
  int yychar = 0;

  /**
   * the number of characters from the last newline up to the start of the
   * matched text
   */
  int yycolumn = 0;

  /**
   * zzAtBOL == true <=> the scanner is currently at the beginning of a line
   */
  bool zzAtBOL = true;

  /** zzAtEOF == true <=> the scanner is at the EOF */
  bool zzAtEOF = false;

  /** denotes if the user-EOF-code has already been executed */
  bool zzEOFDone = false;

  /**
   * The number of occupied positions in zzBuffer beyond zzEndRead.
   * When a lead/high surrogate has been read from the input stream
   * into the final zzBuffer position, this will have a value of 1;
   * otherwise, it will have a value of 0.
   */
  int zzFinalHighSurrogate = 0;

  /* user code: */
  static const std::unordered_map<std::wstring, std::wstring>
      upperCaseVariantsAccepted;

private:
  class StaticConstructor
      : public std::enable_shared_from_this<StaticConstructor>
  {
    GET_CLASS_NAME(StaticConstructor)
  public:
    StaticConstructor();
  };

private:
  static HTMLStripCharFilter::StaticConstructor staticConstructor;

  static const std::shared_ptr<CharArrayMap<wchar_t>> entityValues;
  static constexpr int INITIAL_INPUT_SEGMENT_SIZE = 1024;
  static constexpr wchar_t BLOCK_LEVEL_START_TAG_REPLACEMENT = L'\n';
  static constexpr wchar_t BLOCK_LEVEL_END_TAG_REPLACEMENT = L'\n';
  static constexpr wchar_t BR_START_TAG_REPLACEMENT = L'\n';
  static constexpr wchar_t BR_END_TAG_REPLACEMENT = L'\n';
  static constexpr wchar_t SCRIPT_REPLACEMENT = L'\n';
  static constexpr wchar_t STYLE_REPLACEMENT = L'\n';
  static constexpr wchar_t REPLACEMENT_CHARACTER = L'\uFFFD';

  std::shared_ptr<CharArraySet> escapedTags = nullptr;
  int inputStart = 0;
  int cumulativeDiff = 0;
  bool escapeBR = false;
  bool escapeSCRIPT = false;
  bool escapeSTYLE = false;
  int restoreState = 0;
  int previousRestoreState = 0;
  int outputCharCount = 0;
  int eofReturnValue = 0;
  std::shared_ptr<TextSegment> inputSegment =
      std::make_shared<TextSegment>(INITIAL_INPUT_SEGMENT_SIZE);
  std::shared_ptr<TextSegment> outputSegment = inputSegment;
  std::shared_ptr<TextSegment> entitySegment = std::make_shared<TextSegment>(2);

  /**
   * Creates a new HTMLStripCharFilter over the provided Reader.
   * @param source Reader to strip html tags from.
   */
public:
  HTMLStripCharFilter(std::shared_ptr<Reader> source);

  /**
   * Creates a new HTMLStripCharFilter over the provided Reader
   * with the specified start and end tags.
   * @param source Reader to strip html tags from.
   * @param escapedTags Tags in this set (both start and end tags)
   *  will not be filtered out.
   */
  HTMLStripCharFilter(std::shared_ptr<Reader> source,
                      std::shared_ptr<Set<std::wstring>> escapedTags);

  int read()  override;

  int read(std::deque<wchar_t> &cbuf, int off,
           int len)  override;

  virtual ~HTMLStripCharFilter();

  static int getInitialBufferSize();

private:
  class TextSegment : public OpenStringBuilder
  {
    GET_CLASS_NAME(TextSegment)
    /** The position from which the next char will be read. */
  public:
    int pos = 0;

    /** Wraps the given buffer and sets this.len to the given length. */
    TextSegment(std::deque<wchar_t> &buffer, int length);

    /** Allocates an internal buffer of the given size. */
    TextSegment(int size);

    /** Sets len = 0 and pos = 0. */
    virtual void clear();

    /** Sets pos = 0 */
    virtual void restart();

    /** Returns the next char in the segment. */
    virtual int nextChar();

    /** Returns true when all characters in the text segment have been read */
    virtual bool isRead();

  protected:
    std::shared_ptr<TextSegment> shared_from_this()
    {
      return std::static_pointer_cast<TextSegment>(
          org.apache.lucene.analysis.util
              .OpenStringBuilder::shared_from_this());
    }
  };

  /**
   * Unpacks the compressed character translation table.
   *
   * @param packed   the packed character translation table
   * @return         the unpacked character translation table
   */
private:
  static std::deque<wchar_t> zzUnpackCMap(const std::wstring &packed);

  /**
   * Refills the input buffer.
   *
   * @return      <code>false</code>, iff there was new input.
   *
   * @exception   java.io.IOException  if any I/O-Error occurs
   */
  bool zzRefill() ;

  /**
   * Closes the input stream.
   */
  void yyclose() ;

  /**
   * Resets the scanner to read from a new input stream.
   * Does not close the old reader.
   *
   * All internal variables are reset, the old input stream
   * <b>cannot</b> be reused (internal buffer is discarded and lost).
   * Lexical state is set to <tt>ZZ_INITIAL</tt>.
   *
   * Internal scan buffer is resized down to its initial length, if it has
   * grown.
   *
   * @param reader   the new input stream
   */
  void yyreset(std::shared_ptr<Reader> reader);

  /**
   * Returns the current lexical state.
   */
  int yystate();

  /**
   * Enters a new lexical state
   *
   * @param newState the new lexical state
   */
  void yybegin(int newState);

  /**
   * Returns the text matched by the current regular expression.
   */
  std::wstring yytext();

  /**
   * Returns the character at position <tt>pos</tt> from the
   * matched text.
   *
   * It is equivalent to yytext().charAt(pos), but faster
   *
   * @param pos the position of the character to fetch.
   *            A value from 0 to yylength()-1.
   *
   * @return the character at position pos
   */
  wchar_t yycharat(int pos);

  /**
   * Returns the length of the matched text region.
   */
  int yylength();

  /**
   * Reports an error that occured while scanning.
   *
   * In a wellformed scanner (no or only correct usage of
   * yypushback(int) and a match-all fallback rule) this method
   * will only be called with things that "Can't Possibly Happen".
   * If this method is called, something is seriously wrong
   * (e.g. a JFlex bug producing a faulty scanner etc.).
   *
   * Usual syntax/scanner level error handling should be done
   * in error fallback rules.
   *
   * @param   errorCode  the code of the errormessage to display
   */
  void zzScanError(int errorCode);

  /**
   * Pushes the specified amount of characters back into the input stream.
   *
   * They will be read again by then next call of the scanning method
   *
   * @param number  the number of characters to be read again.
   *                This number must not be greater than yylength()!
   */
  void yypushback(int number);

  /**
   * Contains user EOF-code, which will be executed exactly once,
   * when the end of file is reached
   */
  void zzDoEOF();

  /**
   * Resumes scanning until the next regular expression is matched,
   * the end of input is encountered or an I/O-Error occurs.
   *
   * @return      the next token
   * @exception   java.io.IOException  if any I/O-Error occurs
   */
  int nextChar() ;

protected:
  std::shared_ptr<HTMLStripCharFilter> shared_from_this()
  {
    return std::static_pointer_cast<HTMLStripCharFilter>(
        BaseCharFilter::shared_from_this());
  }
};

} // #include  "core/src/java/org/apache/lucene/analysis/charfilter/
