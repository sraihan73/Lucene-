#pragma once
#include "exceptionhelper.h"
#include "stringhelper.h"
#include <memory>
#include <string>
#include <deque>

// C++ NOTE: Forward class declarations:
namespace org::apache::lucene::queryparser::classic
{
class CharStream;
}

namespace org::apache::lucene::queryparser::classic
{
class Token;
}

/* Generated By:JavaCC: Do not edit this line. QueryParserTokenManager.java */
namespace org::apache::lucene::queryparser::classic
{

/** Token Manager. */
// C++ TODO: Most Java annotations will not have direct C++ equivalents:
// ORIGINAL LINE: @SuppressWarnings("cast") public class QueryParserTokenManager
// implements QueryParserConstants
class QueryParserTokenManager
    : public std::enable_shared_from_this<QueryParserTokenManager>,
      public QueryParserConstants
{

private:
  int jjStopStringLiteralDfa_2(int pos, int64_t active0);
  int jjStartNfa_2(int pos, int64_t active0);
  int jjStopAtPos(int pos, int kind);
  int jjMoveStringLiteralDfa0_2();
  int jjStartNfaWithStates_2(int pos, int kind, int state);

public:
  static std::deque<int64_t> const jjbitVec0;
  static std::deque<int64_t> const jjbitVec1;
  static std::deque<int64_t> const jjbitVec3;
  static std::deque<int64_t> const jjbitVec4;

private:
  int jjMoveNfa_2(int startState, int curPos);
  int jjMoveStringLiteralDfa0_0();
  int jjMoveNfa_0(int startState, int curPos);
  int jjStopStringLiteralDfa_1(int pos, int64_t active0);
  int jjStartNfa_1(int pos, int64_t active0);
  int jjMoveStringLiteralDfa0_1();
  int jjMoveStringLiteralDfa1_1(int64_t active0);
  int jjStartNfaWithStates_1(int pos, int kind, int state);
  int jjMoveNfa_1(int startState, int curPos);

public:
  static std::deque<int> const jjnextStates;

private:
  static bool jjCanMove_0(int hiByte, int i1, int i2, int64_t l1,
                          int64_t l2);
  static bool jjCanMove_1(int hiByte, int i1, int i2, int64_t l1,
                          int64_t l2);
  static bool jjCanMove_2(int hiByte, int i1, int i2, int64_t l1,
                          int64_t l2);

  /** Token literal values. */
public:
  static std::deque<std::wstring> const jjstrLiteralImages;

  /** Lexer state names. */
  static std::deque<std::wstring> const lexStateNames;

  /** Lex State array. */
  static std::deque<int> const jjnewLexState;
  static std::deque<int64_t> const jjtoToken;
  static std::deque<int64_t> const jjtoSkip;

protected:
  std::shared_ptr<CharStream> input_stream;

private:
  std::deque<int> const jjrounds = std::deque<int>(49);
  std::deque<int> const jjstateSet = std::deque<int>(98);

protected:
  wchar_t curChar = L'\0';
  /** Constructor. */
public:
  QueryParserTokenManager(std::shared_ptr<CharStream> stream);

  /** Constructor. */
  QueryParserTokenManager(std::shared_ptr<CharStream> stream, int lexState);

  /** Reinitialise parser. */
  virtual void ReInit(std::shared_ptr<CharStream> stream);

private:
  void ReInitRounds();

  /** Reinitialise parser. */
public:
  virtual void ReInit(std::shared_ptr<CharStream> stream, int lexState);

  /** Switch to specified lex state. */
  virtual void SwitchTo(int lexState);

protected:
  virtual std::shared_ptr<Token> jjFillToken();

public:
  int curLexState = 2;
  int defaultLexState = 2;
  int jjnewStateCnt = 0;
  int jjround = 0;
  int jjmatchedPos = 0;
  int jjmatchedKind = 0;

  /** Get the next Token. */
  virtual std::shared_ptr<Token> getNextToken();

private:
  void jjCheckNAdd(int state);
  void jjAddStates(int start, int end);
  void jjCheckNAddTwoStates(int state1, int state2);

  void jjCheckNAddStates(int start, int end);
};

} // namespace org::apache::lucene::queryparser::classic
