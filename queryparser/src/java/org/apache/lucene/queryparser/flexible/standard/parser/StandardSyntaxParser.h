#pragma once
#include "exceptionhelper.h"
#include "stringhelper.h"
#include <memory>
#include <stdexcept>
#include <string>
#include <deque>

// C++ NOTE: Forward class declarations:
#include  "core/src/java/org/apache/lucene/queryparser/flexible/core/QueryNodeParseException.h"

#include  "core/src/java/org/apache/lucene/queryparser/flexible/core/nodes/QueryNode.h"
#include  "core/src/java/org/apache/lucene/queryparser/flexible/core/nodes/ModifierQueryNode.h"
#include  "core/src/java/org/apache/lucene/queryparser/flexible/standard/parser/ParseException.h"
#include  "core/src/java/org/apache/lucene/queryparser/flexible/standard/parser/StandardSyntaxParserTokenManager.h"
#include  "core/src/java/org/apache/lucene/queryparser/flexible/standard/parser/Token.h"
#include  "core/src/java/org/apache/lucene/queryparser/flexible/standard/parser/JJCalls.h"
#include  "core/src/java/org/apache/lucene/queryparser/flexible/standard/parser/CharStream.h"

/* Generated By:JavaCC: Do not edit this line. StandardSyntaxParser.java */
namespace org::apache::lucene::queryparser::flexible::standard::parser
{

/*
 * Licensed to the Syed Mamun Raihan (sraihan.com) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * sraihan.com licenses this file to You under GPLv3 License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     https://www.gnu.org/licenses/gpl-3.0.en.html
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

using QueryNodeParseException =
    org::apache::lucene::queryparser::flexible::core::QueryNodeParseException;
using ModifierQueryNode =
    org::apache::lucene::queryparser::flexible::core::nodes::ModifierQueryNode;
using QueryNode =
    org::apache::lucene::queryparser::flexible::core::nodes::QueryNode;
using SyntaxParser =
    org::apache::lucene::queryparser::flexible::core::parser::SyntaxParser;

/**
 * Parser for the standard Lucene syntax
 */
class StandardSyntaxParser
    : public std::enable_shared_from_this<StandardSyntaxParser>,
      public SyntaxParser,
      public StandardSyntaxParserConstants
{
  GET_CLASS_NAME(StandardSyntaxParser)

  // syntax parser constructor
public:
  StandardSyntaxParser();
  /** Parses a query string, returning a {@link
   * org.apache.lucene.queryparser.flexible.core.nodes.QueryNode}.
   *  @param query  the query string to be parsed.
   *  @throws ParseException if the parsing fails
   */
  std::shared_ptr<QueryNode>
  parse(std::shared_ptr<std::wstring> query,
        std::shared_ptr<std::wstring> field) 
      override;

  ModifierQueryNode::Modifier Modifiers() ;

  // This makes sure that there is no garbage after the query string
  std::shared_ptr<QueryNode>
  TopLevelQuery(std::shared_ptr<std::wstring> field) ;

  // These changes were made to introduce operator precedence:
  // - Clause() now returns a QueryNode.
  // - The modifiers are consumed by Clause() and returned as part of the
  // QueryNode Object
  // - Query does not consume conjunctions (AND, OR) anymore.
  // - This is now done by two new non-terminals: ConjClause and DisjClause
  // The parse tree looks similar to this:
  //       Query ::= DisjQuery ( DisjQuery )*
  //   DisjQuery ::= ConjQuery ( OR ConjQuery )*
  //   ConjQuery ::= Clause ( AND Clause )*
  //      Clause ::= [ Modifier ] ...
  std::shared_ptr<QueryNode>
  Query(std::shared_ptr<std::wstring> field) ;

  std::shared_ptr<QueryNode>
  DisjQuery(std::shared_ptr<std::wstring> field) ;

  std::shared_ptr<QueryNode>
  ConjQuery(std::shared_ptr<std::wstring> field) ;

  // QueryNode Query(std::wstring field) :
  // {
  // List clauses = new ArrayList();
  //   List modifiers = new ArrayList();
  //   QueryNode q, firstQuery=null;
  //   ModifierQueryNode.Modifier mods;
  //   int conj;
  // }
  // {
  //   mods=Modifiers() q=Clause(field)
  //   {
  //     if (mods == ModifierQueryNode.Modifier.MOD_NONE) firstQuery=q;
  //
  //     // do not create modifier nodes with MOD_NONE
  //      if (mods != ModifierQueryNode.Modifier.MOD_NONE) {
  //          q = new ModifierQueryNode(q, mods);
  //         }
  //      clauses.add(q);
  //   }
  //   (
  //     conj=Conjunction() mods=Modifiers() q=Clause(field)
  //     {
  //       // do not create modifier nodes with MOD_NONE
  //         if (mods != ModifierQueryNode.Modifier.MOD_NONE) {
  //          q = new ModifierQueryNode(q, mods);
  //         }
  //          clauses.add(q);
  //        //TODO: figure out what to do with AND and ORs
  //   }
  //   )*
  //     {
  //      if (clauses.size() == 1 && firstQuery != null)
  //         return firstQuery;
  //       else {
  //       return new BooleanQueryNode(clauses);
  //       }
  //     }
  // }
  std::shared_ptr<QueryNode>
  ModClause(std::shared_ptr<std::wstring> field) ;

  std::shared_ptr<QueryNode>
  Clause(std::shared_ptr<std::wstring> field) ;

  std::shared_ptr<QueryNode>
  Term(std::shared_ptr<std::wstring> field) ;

private:
  bool jj_2_1(int xla);

  bool jj_2_2(int xla);

  bool jj_3R_12();

  bool jj_3R_11();

  bool jj_3_1();

  bool jj_3R_8();

  bool jj_3R_10();

  bool jj_3R_7();

  bool jj_3R_9();

  bool jj_3R_5();

  bool jj_3R_4();

  bool jj_3R_6();

  bool jj_3_2();

  /** Generated Token Manager. */
public:
  std::shared_ptr<StandardSyntaxParserTokenManager> token_source;
  /** Current token. */
  std::shared_ptr<Token> token;
  /** Next token. */
  std::shared_ptr<Token> jj_nt;

private:
  // C++ NOTE: Fields cannot have the same name as methods:
  int jj_ntk_ = 0;
  std::shared_ptr<Token> jj_scanpos, jj_lastpos;
  int jj_la = 0;
  int jj_gen = 0;
  std::deque<int> const jj_la1 = std::deque<int>(25);
  static std::deque<int> jj_la1_0;
  static std::deque<int> jj_la1_1;

private:
  class StaticConstructor
      : public std::enable_shared_from_this<StaticConstructor>
  {
    GET_CLASS_NAME(StaticConstructor)
  public:
    StaticConstructor();
  };

private:
  static StandardSyntaxParser::StaticConstructor staticConstructor;

  static void jj_la1_init_0();
  static void jj_la1_init_1();
  std::deque<std::shared_ptr<JJCalls>> const jj_2_rtns =
      std::deque<std::shared_ptr<JJCalls>>(2);
  bool jj_rescan = false;
  int jj_gc = 0;

  /** Constructor with user supplied CharStream. */
public:
  StandardSyntaxParser(std::shared_ptr<CharStream> stream);

  /** Reinitialise. */
  virtual void ReInit(std::shared_ptr<CharStream> stream);

  /** Constructor with generated Token Manager. */
  StandardSyntaxParser(std::shared_ptr<StandardSyntaxParserTokenManager> tm);

  /** Reinitialise. */
  virtual void ReInit(std::shared_ptr<StandardSyntaxParserTokenManager> tm);

private:
  std::shared_ptr<Token> jj_consume_token(int kind) ;

private:
  class LookaheadSuccess final : public java::lang::Error
  {
    GET_CLASS_NAME(LookaheadSuccess)

  protected:
    std::shared_ptr<LookaheadSuccess> shared_from_this()
    {
      return std::static_pointer_cast<LookaheadSuccess>(
          java.lang.Error::shared_from_this());
    }
  };

private:
  const std::shared_ptr<LookaheadSuccess> jj_ls =
      std::make_shared<LookaheadSuccess>();
  bool jj_scan_token(int kind);

  /** Get the next Token. */
public:
  std::shared_ptr<Token> getNextToken();

  /** Get the specific Token. */
  std::shared_ptr<Token> getToken(int index);

private:
  int jj_ntk();

  std::deque<std::deque<int>> jj_expentries = std::deque<std::deque<int>>();
  std::deque<int> jj_expentry;
  int jj_kind = -1;
  std::deque<int> jj_lasttokens = std::deque<int>(100);
  int jj_endpos = 0;

  void jj_add_error_token(int kind, int pos);

  /** Generate ParseException. */
public:
  virtual std::shared_ptr<ParseException> generateParseException();

  /** Enable tracing. */
  void enable_tracing();

  /** Disable tracing. */
  void disable_tracing();

private:
  void jj_rescan_token();

  void jj_save(int index, int xla);

public:
  class JJCalls final : public std::enable_shared_from_this<JJCalls>
  {
    GET_CLASS_NAME(JJCalls)
  public:
    int gen = 0;
    std::shared_ptr<Token> first;
    int arg = 0;
    std::shared_ptr<JJCalls> next;
  };
};

} // #include  "core/src/java/org/apache/lucene/queryparser/flexible/standard/parser/
