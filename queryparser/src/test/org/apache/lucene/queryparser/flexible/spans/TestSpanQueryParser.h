#pragma once
#include "stringhelper.h"
#include <memory>
#include <stdexcept>
#include <string>

// C++ NOTE: Forward class declarations:
#include  "core/src/java/org/apache/lucene/queryparser/flexible/core/processors/QueryNodeProcessorPipeline.h"

#include  "core/src/java/org/apache/lucene/queryparser/flexible/spans/SpansQueryConfigHandler.h"
#include  "core/src/java/org/apache/lucene/queryparser/flexible/spans/SpansQueryTreeBuilder.h"
#include  "core/src/java/org/apache/lucene/queryparser/flexible/core/parser/SyntaxParser.h"
#include  "core/src/java/org/apache/lucene/search/spans/SpanQuery.h"
#include  "core/src/java/org/apache/lucene/queryparser/flexible/core/QueryNodeException.h"

/*
 * Licensed to the Syed Mamun Raihan (sraihan.com) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * sraihan.com licenses this file to You under GPLv3 License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     https://www.gnu.org/licenses/gpl-3.0.en.html
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
namespace org::apache::lucene::queryparser::flexible::spans
{

using QueryNodeException =
    org::apache::lucene::queryparser::flexible::core::QueryNodeException;
using SyntaxParser =
    org::apache::lucene::queryparser::flexible::core::parser::SyntaxParser;
using QueryNodeProcessorPipeline = org::apache::lucene::queryparser::flexible::
    core::processors::QueryNodeProcessorPipeline;
using StandardSyntaxParser = org::apache::lucene::queryparser::flexible::
    standard::parser::StandardSyntaxParser;
using SpanQuery = org::apache::lucene::search::spans::SpanQuery;
using LuceneTestCase = org::apache::lucene::util::LuceneTestCase;

/**
 * This test case demonstrates how the new query parser can be used.<br>
 * <br>
 *
 * It tests queries likes "term", "field:term" "term1 term2" "term1 OR term2",
 * which are all already supported by the current syntax parser (
 * {@link StandardSyntaxParser}).<br>
 * <br>
 *
 * The goals is to create a new query parser that supports only the pair
 * "field:term" or a deque of pairs separated or not by an OR operator, and from
 * this query generate {@link SpanQuery} objects instead of the regular
 * {@link Query} objects. Basically, every pair will be converted to a
 * {@link SpanTermQuery} object and if there are more than one pair they will be
 * grouped by an {@link OrQueryNode}.<br>
 * <br>
 *
 * Another functionality that will be added is the ability to convert every
 * field defined in the query to an unique specific field.<br>
 * <br>
 *
 * The query generation is divided in three different steps: parsing (syntax),
 * processing (semantic) and building.<br>
 * <br>
 *
 * The parsing phase, as already mentioned will be performed by the current
 * query parser: {@link StandardSyntaxParser}.<br>
 * <br>
 *
 * The processing phase will be performed by a processor pipeline which is
 * compound by 2 processors: {@link SpansValidatorQueryNodeProcessor} and
 * {@link UniqueFieldQueryNodeProcessor}.
 *
 * <pre>
 *
 *   {@link SpansValidatorQueryNodeProcessor}: as it's going to use the current
 *   query parser to parse the syntax, it will support more features than we
 * want, this processor basically validates the query node tree generated by the
 * parser and just let got through the elements we want, all the other elements
 * as wildcards, range queries, etc...if found, an exception is thrown.
 *
 *   {@link UniqueFieldQueryNodeProcessor}: this processor will take care of
 * reading what is the &quot;unique field&quot; from the configuration and
 * convert every field defined in every pair to this &quot;unique field&quot;.
 * For that, a {@link SpansQueryConfigHandler} is used, which has the {@link
 * UniqueFieldAttribute} defined in it.
 * </pre>
 *
 * The building phase is performed by the {@link SpansQueryTreeBuilder}, which
 * basically contains a map_obj that defines which builder will be used to generate
 * {@link SpanQuery} objects from {@link QueryNode} objects.<br>
 * <br>
 *
 * @see SpansQueryConfigHandler
 * @see SpansQueryTreeBuilder
 * @see SpansValidatorQueryNodeProcessor
 * @see SpanOrQueryNodeBuilder
 * @see SpanTermQueryNodeBuilder
 * @see StandardSyntaxParser
 * @see UniqueFieldQueryNodeProcessor
 * @see UniqueFieldAttribute
 */
class TestSpanQueryParser : public LuceneTestCase
{
  GET_CLASS_NAME(TestSpanQueryParser)

private:
  std::shared_ptr<QueryNodeProcessorPipeline> spanProcessorPipeline;

  std::shared_ptr<SpansQueryConfigHandler> spanQueryConfigHandler;

  std::shared_ptr<SpansQueryTreeBuilder> spansQueryTreeBuilder;

  std::shared_ptr<SyntaxParser> queryParser =
      std::make_shared<StandardSyntaxParser>();

public:
  TestSpanQueryParser();

  void setUp()  override;

  virtual std::shared_ptr<SpanQuery>
  getSpanQuery(std::shared_ptr<std::wstring> query) ;

  virtual std::shared_ptr<SpanQuery>
  getSpanQuery(const std::wstring &uniqueField,
               std::shared_ptr<std::wstring> query) ;

  virtual void testTermSpans() ;

  virtual void testUniqueField() ;

  virtual void testOrSpans() ;

  virtual void testQueryValidator() ;

protected:
  std::shared_ptr<TestSpanQueryParser> shared_from_this()
  {
    return std::static_pointer_cast<TestSpanQueryParser>(
        org.apache.lucene.util.LuceneTestCase::shared_from_this());
  }
};

} // #include  "core/src/java/org/apache/lucene/queryparser/flexible/spans/
